---
layout: post
title: Drops - Dev Thoughts
date: 2016-05-22
author: Lemon
---

<video src="{{ site.github.url }}/images/drops/drops_loop.webm" autoplay loop></video>

Drops are the game's main collectible currency. They were inspired by the Japanese sweet, konpeitos, while the name came from a British sweet which also looks similar.

<img src="{{ site.github.url }}/images/drops/drops_inspired.jpg" width="280"/>  <img src="{{ site.github.url }}/images/drops/drops_inspired2.jpg" height="210"/>

Started on these early on during the project because 1. I wanted to and 2. I thought they would be quick and simple to make. You'd think I would've stopped making these assumptions by now.

### GameObject
Originally the drop was made up of separate GameObjects. This was done because:

I needed a sphere collider for both triggering the attraction and the drop itself.  
Unity only allows 1 type of each collider on a gameobject and there's no (clean) way of knowing which collider is being triggered even if it did.  
Tried to get round this by using a non-trigger cube collider for the drop but there was a noticeable delay between the thing smacking against the player's body and the code being triggered to pick it up.

Another reason was because audio and particle effects stop immediately once an object is set inactive.

This approach had a few problems. It required the dev to set up the objects and scripts in a certain way, prone to error when we make the next set of collectibles.  
It also made it a pain to reference scripts from another object because I needed to get the components from the children and sort through them etc.

Reworked it so everything could be attached to a single parent.  
I got round the multiple colliders problem by using a range check in the script instead. I draw a gizmo to visualize the sphere in the Unity scene view.  
For the 2nd problem, I added a global manager system which spawns particle/sound effects from object pools, (they'll also store themselves back in once they've finished).

### Looks and behaviour

Added a trail as it flies towards the player to make it look faster and a particle effect similar to shattering glass when the player touches it to make it feel more satisfying.  
The glow is a halo done with the light component. The light itself is disabled for now, might experiment with enabling the lights later if I make a dark level, will have to check the performance though.

The colours aren't random but are cycled because it looks nice when the colours are evenly distributed.  

Instead of just floating into the player when they get close, the drop will hop straight up, freeze for a second before shooting at the player. It feels more satisfying with this.  
Making sure the player actually has line of sight with the drop so they don't start attracting through walls.

The speed the drop flies at the player is fast enough to easily catch up but the air resistance is low enough for the drop to "skid" and curve through the air creating nice swirly patterns with the trails.  

They all slowly spin and float up and down (at slightly different speeds to each other) to add a bit of life into the levels. We don't have any artists so we figured the levels might feel barren without these little details.

### Populating the levels

Turns out that having over 100 colliding objects in close proximity will tank the frame rate.

<video src="{{ site.github.url }}/images/drops/drops_collision.webm" autoplay loop width="300"></video>

Why even make them physics objects though? For easier level creation.  
Instead of wasting time carefully placing all the drops at the right height, I thought it would be quicker if they had gravity and would automatically fall to the ground.  
Still, this involves a lot of copy and paste so I scrapped it.

The global pool manager was extended so it could spawn gameobjects, mainly for collectibles/power ups and enemies.  
Now it's used for these 2 tools:

<img src="{{ site.github.url }}/images/drops/drops_line.jpg" width="400"/>

Found the bezier curves online but this ended up being much easier to implement than I thought.

The second tool spews gameobjects out in random directions.  
Ended up being harder than I originally thought though I may have made it more difficult for myself than needed.  
Math'ed myself random points on a sphere within a given angle to get the spawning directions but in hindsight maybe just a random x + random z would've been good enough.  
There'll be a video of this in action further down.

### Audio

This will be easy right? Find some satisfying foley, drop in the file and I'm done right?

Warning: volume/cancer
<video src="{{ site.github.url }}/images/drops/drops_sound_jar.webm" controls width="600"></video>

A few techniques I tried:

Used a different sound effect.  
I tried out a few more foley-type effects, they all sounded obnoxious honestly when repeated so frequently.  
Tried something abstract/gamey and found a few which sounded decent but didn't fit. I settled with an inoffensive sparkly effect in the end.

Random variations of the pitch, volume and length of the sound clip.  
This helped reduced the cancer element a lot since they were no longer resonating with each other. Plus added a little variation.

Cull sound clips played too close to each other and increased the delay between each spawn.  
This had the half-unintended side effect of making it look like the drops were streaming out the spawn point which I totally loved.

Increase the pitch after consecutive pick ups.  
Tried this with the individually spawned drops. Didn't quite work out as you pick up a lot at once compared to the other games that try this.  
I did leave it in but only subtly. 

### Final result

<video src="{{ site.github.url }}/images/drops/drops final.webm" controls width="600"></video>

Will probably continue to tweak it but I'm happy with it. I need to work on the rest of the game.  
In hindsight I should've waited till we knew what our "crate" of the game will be before making that spawning particle effect.  